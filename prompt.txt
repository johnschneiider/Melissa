Estoy creando un sistema de reservas tipo SaaS con Django. Quiero incluir confirmaciones por llamada automatizada con IA (GPT o similar), y fallback a WhatsApp si no contestan. Necesito diseñar la arquitectura para: reservas, recordatorios, confirmación, cancelación, reagendamiento y un panel de recepción. Quiero que me ayudes a definir el MVP, base de datos, flujo de usuarios y automatización con IA.
El proyecto actualmente tiene errores. Antes de pasar e la confirmacion quiero que me ayudes a optimizar, aumentar la seguridad y cuando yo vea que todo anda bien, continuar con lo faltante.

actualmente tengo un proyecto creado el cual cuenta con tres aplicaciones: clientes, cuentas y negocios.
recuerda que no estoy en un entorno de produccion sino en un entorno de prueba y desarrollo.
a continuacion te dejo el codigo y no quiero que comiences ayudar hasta que te diga termine

settings.py
"""
Django settings for melissa project.

Generated by 'django-admin startproject' using Django 5.2.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-(*+19^2ahsob+p6v4)nuo-x5b)jn#4l-riagw(qonl6(5f&w9='

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []
AUTH_USER_MODEL = 'cuentas.UsuarioPersonalizado'


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    #mis apps
    'cuentas',
    'clientes',
    'negocios',  
    'widget_tweaks',

    
    #Autenticacioni con google o facebook
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',

    # Proveedores sociales google y facebook
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.facebook',
]
SITE_ID = 1

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

LOGIN_REDIRECT_URL = '/' 
ACCOUNT_LOGOUT_REDIRECT_URL = '/'  # opcional
LOGIN_URL = '/accounts/login/'
LOGIN_REDIRECT_URL = 'clientes:lista_negocios'
LOGOUT_REDIRECT_URL = 'clientes:lista_negocios'

ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USERNAME_REQUIRED = True
ACCOUNT_AUTHENTICATION_METHOD = 'username_email'
SOCIALACCOUNT_AUTO_SIGNUP = True
SOCIALACCOUNT_LOGIN_ON_GET = True


CLIENT_ID = "1021577441313-n5qjqhrdiptb5hqk4lvb504tevpih70d.apps.googleusercontent.com"
sECRET_cLIENT = "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"


EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'vital.mix324@gmail.com'
EMAIL_HOST_PASSWORD = 'yhhlmtxggcdkivay'  # sin espacios
DEFAULT_FROM_EMAIL = 'Melissa <vital.mix324@gmail.com>'




MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'allauth.account.middleware.AccountMiddleware',

]

ROOT_URLCONF = 'melissa.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'melissa.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'es-co'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'


# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
import os

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

urls.py del proyecto principal
from django.contrib import admin
from django.urls import path, include
from django.shortcuts import render
from django.conf import settings
from django.conf.urls.static import static

def inicio(request):
    return render(request, 'inicio.html')

urlpatterns = [
    path('admin/', admin.site.urls),
    path('cuentas/', include('cuentas.urls')),
    path('accounts/', include('allauth.urls')),
    path('', inicio, name='inicio'),
    path('negocios/', include('negocios.urls')),
    path('clientes/', include('clientes.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

clientes.forms.py
from django import forms
from django.utils import timezone
from datetime import datetime
from .models import Reserva
from negocios.models import ImagenGaleria

class ReservaForm(forms.ModelForm):
    servicio = forms.ModelChoiceField(
        queryset=ImagenGaleria.objects.none(),
        required=False,
        label="Servicio (opcional)"
    )
    
    class Meta:
        model = Reserva
        fields = ['fecha', 'hora_inicio', 'servicio', 'notas']
        widgets = {
            'fecha': forms.DateInput(attrs={'type': 'date'}),
            'hora_inicio': forms.TimeInput(attrs={'type': 'time'}),
            'notas': forms.Textarea(attrs={'rows': 3}),
        }

    def __init__(self, *args, peluquero=None, **kwargs):
        super().__init__(*args, **kwargs)
        if peluquero:
            self.fields['servicio'].queryset = ImagenGaleria.objects.filter(
                peluquero=peluquero
            ).order_by('nombre')
            
    def clean(self):
        cleaned_data = super().clean()
        fecha = cleaned_data.get('fecha')
        hora_inicio = cleaned_data.get('hora_inicio')
        
        if fecha and hora_inicio:
            # Hacer que la fecha/hora de reserva sea aware
            fecha_hora_reserva = timezone.make_aware(
                datetime.combine(fecha, hora_inicio))
            
            # Comparar con la hora actual (ya es aware)
            if fecha_hora_reserva < timezone.now():
                raise forms.ValidationError("No puedes reservar en fechas/horas pasadas.")
                
        return cleaned_data

clientes.models.py
from django.db import models
from negocios.models import Negocio, Peluquero
from django.conf import settings

class Reserva(models.Model):
    cliente = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    peluquero = models.ForeignKey(Peluquero, on_delete=models.CASCADE)
    fecha = models.DateField()
    hora_inicio = models.TimeField()
    hora_fin = models.TimeField()
    servicio = models.ForeignKey('negocios.ImagenGaleria', on_delete=models.SET_NULL, null=True, blank=True)
    creado_en = models.DateTimeField(auto_now_add=True)
    estado = models.CharField(max_length=20, choices=[
        ('pendiente', 'Pendiente'),
        ('confirmado', 'Confirmado'),
        ('cancelado', 'Cancelado'),
        ('completado', 'Completado'),
    ], default='pendiente')
    notas = models.TextField(blank=True)

    class Meta:
        ordering = ['fecha', 'hora_inicio']
        verbose_name = 'Reserva'
        verbose_name_plural = 'Reservas'

    def __str__(self):
        return f"Reserva de {self.cliente} con {self.peluquero} el {self.fecha} a las {self.hora_inicio}"


clientes.urls.py
from django.urls import path
from .views import (
    ListaNegociosView,
    DetallePeluqueroView,
    reservar_turno,
    confirmacion_reserva,
    horarios_disponibles
)

app_name = 'clientes'

urlpatterns = [
    path('', ListaNegociosView.as_view(), name='lista_negocios'),
    path('peluquero/<int:pk>/', DetallePeluqueroView.as_view(), name='detalle_peluquero'),
    path('peluquero/<int:peluquero_id>/reservar/', reservar_turno, name='reservar_turno'),
    path('reserva/<int:reserva_id>/confirmacion/', confirmacion_reserva, name='confirmacion_reserva'),
    path('api/horarios-disponibles/<int:peluquero_id>/', horarios_disponibles, name='horarios_disponibles'),
    path('negocios/', ListaNegociosView.as_view(), name='lista_negocios'),
    path('confirmacion/<int:reserva_id>/', confirmacion_reserva, name='confirmacion_reserva'),
]


clientes.views.py
from django.shortcuts import render, get_object_or_404, redirect
from django.views.generic import ListView, DetailView
from django.utils import timezone
from datetime import timedelta, datetime, time
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from negocios.models import Negocio, Peluquero, ImagenGaleria
from .models import Reserva
from .forms import ReservaForm
import json
import holidays

class ListaNegociosView(ListView):
    model = Negocio
    template_name = 'clientes/lista_negocios.html'
    context_object_name = 'negocios'
    
    def get_queryset(self):
        return Negocio.objects.filter(activo=True).prefetch_related('peluqueros')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Obtener todos los peluqueros activos para cada negocio
        negocios_con_peluqueros = []
        for negocio in context['negocios']:
            peluqueros = negocio.peluqueros.filter(activo=True)
            negocios_con_peluqueros.append({
                'negocio': negocio,
                'peluqueros': peluqueros
            })
        context['negocios_con_peluqueros'] = negocios_con_peluqueros
        return context

class DetallePeluqueroView(DetailView):
    model = Peluquero
    template_name = 'clientes/detalle_peluquero.html'
    context_object_name = 'peluquero'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        peluquero = self.object
        
        # Obtener los próximos 14 días de disponibilidad
        hoy = timezone.now().date()
        proximos_dias = [hoy + timedelta(days=i) for i in range(14)]
        
        # Verificar días festivos
        co_holidays = holidays.CountryHoliday('CO')
        
        dias_disponibilidad = []
        for dia in proximos_dias:
            nombre_dia = dia.strftime('%A')
            nombre_dia_es = {
                'Monday': 'Lunes',
                'Tuesday': 'Martes',
                'Wednesday': 'Miércoles',
                'Thursday': 'Jueves',
                'Friday': 'Viernes',
                'Saturday': 'Sábado',
                'Sunday': 'Domingo'
            }.get(nombre_dia, nombre_dia)
            
            es_festivo = dia in co_holidays or nombre_dia_es == 'Domingo'
            
            # Obtener horario del peluquero para este día
            horario_peluquero = peluquero.horario.get(nombre_dia_es, {})
            turnos = horario_peluquero.get('turnos', [])
            
            # Verificar reservas existentes para este día
            reservas_dia = Reserva.objects.filter(
                peluquero=peluquero,
                fecha=dia,
                estado__in=['pendiente', 'confirmado']
            ).values_list('hora_inicio', 'hora_fin')
            
            # Calcular intervalos disponibles
            intervalos_disponibles = []
            for turno in turnos:
                if turno.get('disponible', True) and not es_festivo:
                    inicio = datetime.strptime(turno['inicio'], '%H:%M').time()
                    fin = datetime.strptime(turno['fin'], '%H:%M').time()
                    duracion = int(turno.get('duracion', 30))
                    
                    # Generar intervalos
                    inicio_minutos = inicio.hour * 60 + inicio.minute
                    fin_minutos = fin.hour * 60 + fin.minute
                    tiempo_actual = inicio_minutos
                    
                    while tiempo_actual + duracion <= fin_minutos:
                        hora_inicio = time(tiempo_actual // 60, tiempo_actual % 60)
                        hora_fin = time((tiempo_actual + duracion) // 60, (tiempo_actual + duracion) % 60)
                        
                        # Verificar si este intervalo está disponible
                        ocupado = False
                        for reserva_inicio, reserva_fin in reservas_dia:
                            if not (hora_fin <= reserva_inicio or hora_inicio >= reserva_fin):
                                ocupado = True
                                break
                                
                        if not ocupado:
                            intervalos_disponibles.append({
                                'inicio': hora_inicio.strftime('%H:%M'),
                                'fin': hora_fin.strftime('%H:%M'),
                                'duracion': duracion
                            })
                            
                        tiempo_actual += duracion
            
            dias_disponibilidad.append({
                'fecha': dia,
                'nombre_dia': nombre_dia_es,
                'festivo': es_festivo,
                'intervalos': intervalos_disponibles
            })
        
        context['dias_disponibilidad'] = dias_disponibilidad
        context['galeria'] = ImagenGaleria.objects.filter(peluquero=peluquero)
        context['hoy'] = hoy
        
        return context

from django.utils import timezone

@login_required
def reservar_turno(request, peluquero_id):
    peluquero = get_object_or_404(Peluquero, id=peluquero_id, negocio__activo=True)
    
    if request.method == 'POST':
        form = ReservaForm(request.POST, peluquero=peluquero)
        if form.is_valid():
            reserva = form.save(commit=False)
            reserva.cliente = request.user
            reserva.peluquero = peluquero
            
            # Calcular hora_fin basado en la duración
            hora_inicio = form.cleaned_data['hora_inicio']
            servicio = form.cleaned_data.get('servicio')
            duracion = servicio.duracion if servicio else 30
            
            # Crear datetime aware para hora_fin
            hora_fin = (timezone.make_aware(
                datetime.combine(form.cleaned_data['fecha'], hora_inicio)
                + timedelta(minutes=duracion)).time())
            
            reserva.hora_fin = hora_fin
            reserva.save()
            messages.success(request, '¡Reserva realizada con éxito!')
            return redirect('clientes:confirmacion_reserva', reserva_id=reserva.id) 
    else:
        form = ReservaForm(peluquero=peluquero)
    
    return render(request, 'clientes/reservar_turno.html', {
        'peluquero': peluquero,
        'form': form
    })
    
def confirmacion_reserva(request, reserva_id):
    reserva = get_object_or_404(Reserva, id=reserva_id, cliente=request.user)
    return render(request, 'clientes/confirmacion_reserva.html', {'reserva': reserva})

def horarios_disponibles(request, peluquero_id):
    peluquero = get_object_or_404(Peluquero, id=peluquero_id)
    fecha = request.GET.get('fecha')
    
    try:
        fecha_obj = datetime.strptime(fecha, '%Y-%m-%d').date()
    except (ValueError, TypeError):
        return JsonResponse({'error': 'Formato de fecha inválido'}, status=400)
    
    # Verificar si es festivo
    co_holidays = holidays.CountryHoliday('CO')
    nombre_dia = fecha_obj.strftime('%A')
    nombre_dia_es = {
        'Monday': 'Lunes',
        'Tuesday': 'Martes',
        'Wednesday': 'Miércoles',
        'Thursday': 'Jueves',
        'Friday': 'Viernes',
        'Saturday': 'Sábado',
        'Sunday': 'Domingo'
    }.get(nombre_dia, nombre_dia)
    
    es_festivo = fecha_obj in co_holidays or nombre_dia_es == 'Domingo'
    
    if es_festivo:
        return JsonResponse({'disponibles': [], 'festivo': True})
    
    # Obtener horario del peluquero para este día
    horario_peluquero = peluquero.horario.get(nombre_dia_es, {})
    turnos = horario_peluquero.get('turnos', [])
    
    # Obtener reservas existentes para este día
    reservas = Reserva.objects.filter(
        peluquero=peluquero,
        fecha=fecha_obj,
        estado__in=['pendiente', 'confirmado']
    ).values_list('hora_inicio', 'hora_fin')
    
    # Calcular horarios disponibles
    horarios_disponibles = []
    for turno in turnos:
        if turno.get('disponible', True):
            inicio = datetime.strptime(turno['inicio'], '%H:%M').time()
            fin = datetime.strptime(turno['fin'], '%H:%M').time()
            duracion = int(turno.get('duracion', 30))
            
            # Generar intervalos
            inicio_minutos = inicio.hour * 60 + inicio.minute
            fin_minutos = fin.hour * 60 + fin.minute
            tiempo_actual = inicio_minutos
            
            while tiempo_actual + duracion <= fin_minutos:
                hora_inicio = time(tiempo_actual // 60, tiempo_actual % 60)
                hora_fin = time((tiempo_actual + duracion) // 60, (tiempo_actual + duracion) % 60)
                
                # Verificar disponibilidad
                disponible = True
                for reserva_inicio, reserva_fin in reservas:
                    if not (hora_fin <= reserva_inicio or hora_inicio >= reserva_fin):
                        disponible = False
                        break
                
                if disponible:
                    horarios_disponibles.append({
                        'hora': hora_inicio.strftime('%H:%M'),
                        'duracion': duracion
                    })
                
                tiempo_actual += duracion
    
    return JsonResponse({'disponibles': horarios_disponibles, 'festivo': False})

cuentas.forms.py
from django import forms
from django.contrib.auth.forms import UserCreationForm
from .models import UsuarioPersonalizado

class ClienteRegistroForm(UserCreationForm):
    telefono = forms.CharField(
        max_length=15,
        required=True,
        label="Teléfono",
        widget=forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Número de teléfono'})
    )

    class Meta:
        model = UsuarioPersonalizado
        fields = ['username', 'email', 'telefono', 'password1', 'password2']

    def __init__(self, *args, **kwargs):
        super(ClienteRegistroForm, self).__init__(*args, **kwargs)
        self.fields['username'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Nombre de usuario'
        })
        self.fields['email'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Correo electrónico'
        })
        self.fields['password1'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Contraseña'
        })
        self.fields['password2'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Repite tu contraseña'
        })

    def save(self, commit=True):
        user = super().save(commit=False)
        user.tipo = 'cliente'
        user.telefono = self.cleaned_data['telefono']
        if commit:
            user.save()
        return user


class NegocioRegistroForm(UserCreationForm):
    telefono = forms.CharField(
        max_length=15,
        required=True,
        label="Teléfono",
        widget=forms.TextInput(attrs={'class': 'form-control', 'placeholder': 'Teléfono de contacto del negocio'})
    )

    class Meta:
        model = UsuarioPersonalizado
        fields = ['username', 'email', 'telefono', 'password1', 'password2']

    def __init__(self, *args, **kwargs):
        super(NegocioRegistroForm, self).__init__(*args, **kwargs)
        self.fields['username'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Nombre del negocio o usuario'
        })
        self.fields['email'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Correo electrónico del negocio'
        })
        self.fields['password1'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Contraseña'
        })
        self.fields['password2'].widget.attrs.update({
            'class': 'form-control',
            'placeholder': 'Repite tu contraseña'
        })

    def save(self, commit=True):
        user = super().save(commit=False)
        user.tipo = 'negocio'
        user.telefono = self.cleaned_data['telefono']
        if commit:
            user.save()
        return user

cuentas.models.py
from django.contrib.auth.models import AbstractUser
from django.db import models

class UsuarioPersonalizado(AbstractUser):
    TIPO_USUARIO = (
        ('cliente', 'Cliente'),
        ('negocio', 'Negocio'),
    )
    tipo = models.CharField(max_length=10, choices=TIPO_USUARIO, default='cliente')
    telefono = models.CharField(max_length=15, blank=True) 


cuentas.urls.py
from django.urls import path
from .views import registro_cliente, registro_negocio, LoginUsuario
from django.contrib.auth.views import LogoutView

urlpatterns = [
    path('registro/cliente/', registro_cliente, name='registro_cliente'),
    path('registro/negocio/', registro_negocio, name='registro_negocio'),
    path('login/', LoginUsuario.as_view(), name='login'),
    path('logout/', LogoutView.as_view(next_page='login'), name='logout'),
]


cuentas.views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login
from .forms import ClienteRegistroForm, NegocioRegistroForm
from django.contrib.auth.views import LoginView
from django.urls import reverse_lazy


def registro_cliente(request):
    if request.method == 'POST':
        form = ClienteRegistroForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('home')  # redirige donde tú quieras
    else:
        form = ClienteRegistroForm()
    return render(request, 'cuentas/registro_cliente.html', {'form': form})


def registro_negocio(request):
    if request.method == 'POST':
        form = NegocioRegistroForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect('home')
    else:
        form = NegocioRegistroForm()
    return render(request, 'cuentas/registro_negocio.html', {'form': form})


class LoginUsuario(LoginView):
    template_name = 'cuentas/login.html'
    redirect_authenticated_user = True
    
    def get_success_url(self):
        # Redirige a la lista de negocios después del login
        return reverse_lazy('clientes:lista_negocios')


negocios.forms.py
from django import forms
from .models import Negocio, Peluquero, ImagenGaleria
from django.core.exceptions import ValidationError
import imghdr

class ImagenGaleriaForm(forms.ModelForm):
    class Meta:
        model = ImagenGaleria
        fields = ['nombre', 'descripcion', 'duracion', 'imagen']
        widgets = {
            'nombre': forms.TextInput(attrs={'class': 'form-control'}),
            'descripcion': forms.Textarea(attrs={'class': 'form-control', 'rows': 2}),
            'duracion': forms.NumberInput(attrs={'class': 'form-control', 'min': 5}),
            'imagen': forms.FileInput(attrs={'class': 'form-control'})
        }



class NegocioForm(forms.ModelForm):
    class Meta:
        model = Negocio
        fields = ['nombre', 'direccion', 'logo']
        widgets = {
            'nombre': forms.TextInput(attrs={'class': 'form-control'}),
            'direccion': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
            'logo': forms.FileInput(attrs={'class': 'form-control'}),
        }


class PeluqueroForm(forms.ModelForm):
    class Meta:
        model = Peluquero
        fields = ['nombre', 'avatar', 'portada', 'horario', 'descripcion']
        widgets = {
            'nombre': forms.TextInput(attrs={'class': 'form-control'}),
            'horario': forms.TextInput(attrs={'class': 'form-control'}),
            'descripcion': forms.Textarea(attrs={'class': 'form-control'}),
        }

    def clean_avatar(self):
        avatar = self.cleaned_data.get('avatar')
        if avatar:
            if imghdr.what(avatar) == 'avif':
                raise ValidationError("El formato AVIF no está permitido.")
        return avatar

    def clean_portada(self):
        portada = self.cleaned_data.get('portada')
        if portada:
            if imghdr.what(portada) == 'avif':
                raise ValidationError("El formato AVIF no está permitido.")
        return portada

negocios.models.py
from django.db import models
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db.models import JSONField
import os
import json

class Negocio(models.Model):
    propietario = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='negocios')
    nombre = models.CharField(max_length=100)
    direccion = models.TextField()
    logo = models.ImageField(upload_to='logos_negocios/', blank=True, null=True)
    creado_en = models.DateTimeField(auto_now_add=True)
    horario_atencion = models.JSONField(default=dict, blank=True, null=True)
    updated_at = models.DateTimeField(auto_now=True)
    activo = models.BooleanField(default=True)
    
    def __str__(self):
        return self.nombre


Usuario = get_user_model()
class Peluquero(models.Model):
    negocio = models.ForeignKey('Negocio', on_delete=models.CASCADE, related_name='peluqueros')
    nombre = models.CharField(max_length=100)
    avatar = models.ImageField(upload_to="peluqueros/", blank=True, null=True)
    portada = models.ImageField(upload_to="portadas_peluqueros/", blank=True, null=True)
    descripcion = models.TextField(blank=True, null=True)
    horario = models.JSONField(default=dict, blank=True)
    updated_at = models.DateTimeField(auto_now=True)
    activo = models.BooleanField(default=True)

    def clean_horario(self):
        """Validar y limpiar la estructura del horario"""
        if isinstance(self.horario, str):
            try:
                self.horario = json.loads(self.horario)
            except json.JSONDecodeError:
                self.horario = {}
        
        if not isinstance(self.horario, dict):
            self.horario = {}
        
        # Estructura básica para días de la semana
        dias_semana = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado', 'Domingo']
        horario_validado = {}
        
        for dia in dias_semana:
            if dia in self.horario and isinstance(self.horario[dia], dict):
                turnos_validados = []
                for turno in self.horario[dia].get('turnos', []):
                    if all(key in turno for key in ['inicio', 'fin', 'duracion']):
                        turnos_validados.append({
                            'inicio': turno['inicio'],
                            'fin': turno['fin'],
                            'duracion': int(turno['duracion']),
                            'disponible': turno.get('disponible', True)
                        })
                horario_validado[dia] = {'turnos': turnos_validados}
        
        return horario_validado

    def save(self, *args, **kwargs):
        self.horario = self.clean_horario()
        super().save(*args, **kwargs)

    def __str__(self):
        return self.nombre
    
class ImagenPeluquero(models.Model):
    peluquero = models.ForeignKey(Peluquero, related_name='imagenes', on_delete=models.CASCADE)
    imagen = models.ImageField(upload_to='cortes/')
    nombre = models.CharField(max_length=100, blank=True)  # Nombre del corte
    descripcion = models.TextField(blank=True)
    duracion = models.PositiveIntegerField(default=30)  # minutos

    def __str__(self):
        return self.nombre or "Corte sin nombre"


# models.py

class ImagenGaleria(models.Model):
    peluquero = models.ForeignKey(
        Peluquero,
        on_delete=models.CASCADE,
        related_name='galeria'
    )
    nombre = models.CharField(max_length=100)
    descripcion = models.TextField(blank=True)
    duracion = models.PositiveIntegerField(default=30, null=True, blank=True)  # minutos
    imagen = models.ImageField(upload_to='galeria/') 
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.nombre or "Corte sin nombre"


negocios.urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('crear/', views.crear_negocio, name='crear_negocio'),
    path('mis/', views.mis_negocios, name='mis_negocios'),
    path('configurar/<int:negocio_id>/', views.configurar_negocio, name='configurar_negocio'),
    path('<int:negocio_id>/panel/', views.panel_negocio, name='panel_negocio'),
    path('<int:negocio_id>/crear-peluquero/', views.crear_peluquero, name='crear_peluquero'),
    path('<int:negocio_id>/peluquero/<int:peluquero_id>/', views.detalle_peluquero, name='detalle_peluquero'),
    path('<int:negocio_id>/peluquero/<int:peluquero_id>/eliminar/', views.eliminar_peluquero, name='eliminar_peluquero'),
    path('<int:negocio_id>/asignar-horario/', views.asignar_horario_negocio, name='asignar_horario_negocio'),
    path('negocios/<int:negocio_id>/eliminar/', views.eliminar_negocio, name='eliminar_negocio'),
    path('negocios/<int:negocio_id>/restaurar/', views.restaurar_negocio, name='restaurar_negocio'),
    path('api/turnos_peluquero/<int:peluquero_id>/', views.api_turnos_peluquero, name='api_turnos_peluquero'),
    path('negocio/<int:negocio_id>/peluquero/<int:peluquero_id>/agregar-imagen/', views.agregar_imagen_galeria, name='agregar_imagen_galeria'),
    path('eliminar-imagen-galeria/<int:imagen_id>/', views.eliminar_imagen_galeria, name='eliminar_imagen_galeria'),

]

negocios.views.py
from .forms import NegocioForm
from django.contrib.auth.decorators import login_required
from .models import Negocio, Peluquero
from django.contrib import messages
from django.shortcuts import render, redirect, get_object_or_404
from django.views.decorators.http import require_POST
from .forms import PeluqueroForm
from .forms import ImagenGaleriaForm
from datetime import datetime, timedelta
from django.http import JsonResponse
import holidays
import json
from .forms import NegocioForm, PeluqueroForm, ImagenGaleriaForm
from .models import Negocio, Peluquero, ImagenGaleria
from datetime import datetime, timedelta, time
import logging
from django.conf import settings



@login_required
def crear_negocio(request):
    print("¿Usuario autenticado?", request.user.is_authenticated)
    print("Tipo de usuario:", repr(request.user.tipo))

    if request.user.tipo.strip().lower() != 'cliente':
        messages.error(request, "Solo los clientes pueden crear negocios.")
        return redirect('inicio')

    if request.method == 'POST':
        form = NegocioForm(request.POST, request.FILES)
        if form.is_valid():
            negocio = form.save(commit=False)
            negocio.propietario = request.user
            negocio.save()
            messages.success(request, "Negocio creado exitosamente.")
            return redirect('panel_negocio', negocio_id=negocio.id)
    else:
        form = NegocioForm()

    return render(request, 'negocios/crear_negocio.html', {'form': form})




@login_required
def mis_negocios(request):
    negocios_activos = request.user.negocios.filter(activo=True)
    negocios_eliminados = request.user.negocios.filter(activo=False)
    tiene_eliminados = negocios_eliminados.exists()

    return render(request, 'negocios/mis_negocios.html', {
        'negocios': negocios_activos,
        'negocios_eliminados': negocios_eliminados,
        'tiene_eliminados': tiene_eliminados,
    })


@require_POST
@login_required
def eliminar_negocio(request, negocio_id):
    negocio = get_object_or_404(Negocio, id=negocio_id, propietario=request.user)
    negocio.activo = False
    negocio.save()
    messages.success(request, "Negocio eliminado correctamente.")
    return redirect('mis_negocios')

@require_POST
@login_required
def restaurar_negocio(request, negocio_id):
    negocio = get_object_or_404(Negocio, id=negocio_id, propietario=request.user, activo=False)
    negocio.activo = True
    negocio.save()
    messages.success(request, f"El negocio '{negocio.nombre}' ha sido restaurado.")
    return redirect('mis_negocios')



@login_required
def configurar_negocio(request, negocio_id):
    negocio = get_object_or_404(Negocio, id=negocio_id, propietario=request.user)

    if request.method == 'POST':
        form = NegocioForm(request.POST, request.FILES, instance=negocio)
        if form.is_valid():
            form.save()
            messages.success(request, "Negocio actualizado.")
            return redirect('configurar_negocio', negocio_id=negocio.id)
    else:
        form = NegocioForm(instance=negocio)

    return render(request, 'negocios/configurar_negocio.html', {'form': form, 'negocio': negocio})



@login_required
def panel_negocio(request, negocio_id):
    negocio = get_object_or_404(Negocio, id=negocio_id, propietario=request.user)

    if request.method == 'POST' and 'logo' in request.FILES:
        negocio.logo = request.FILES['logo']
        negocio.save()
        messages.success(request, "Logo actualizado correctamente.")
        return redirect('panel_negocio', negocio_id=negocio.id)

    peluqueros = negocio.peluqueros.filter(activo=True)
    dias = ["Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"]

    horario_guardado = {}
    for dia in dias:
        base = negocio.horario_atencion.get(dia, {})
        horario_guardado[f"{dia}_inicio"] = base.get("inicio", "")
        horario_guardado[f"{dia}_fin"] = base.get("fin", "")
        horario_guardado[f"{dia}_activo"] = bool(base)

    return render(request, 'negocios/panel_negocio.html', {
        'negocio': negocio,
        'peluqueros': peluqueros,
        'dias': dias,
        'horario_guardado': horario_guardado,
    })



@login_required
def crear_peluquero(request, negocio_id):
    negocio = get_object_or_404(Negocio, id=negocio_id, propietario=request.user)

    #if negocio.peluqueros.exists():
    #    messages.info(request, "Este negocio ya tiene un peluquero asignado.")
    #    return redirect('panel_negocio', negocio_id=negocio.id)

    Peluquero.objects.create(
        negocio=negocio,
        nombre="Peluquero Default",
        horario="Lunes a Viernes de 9am a 6pm"
    )

    messages.success(request, "Peluquero creado correctamente.")
    return redirect('panel_negocio', negocio_id=negocio.id)


from .models import Peluquero
@login_required
def detalle_peluquero(request, negocio_id, peluquero_id):
    peluquero = get_object_or_404(
        Peluquero, 
        id=peluquero_id, 
        negocio_id=negocio_id, 
        negocio__propietario=request.user
    )
    
    # Configuración de días de la semana
    DIAS_SEMANA = [
        {'nombre': 'Lunes', 'festivo': False},
        {'nombre': 'Martes', 'festivo': False},
        {'nombre': 'Miércoles', 'festivo': False},
        {'nombre': 'Jueves', 'festivo': False},
        {'nombre': 'Viernes', 'festivo': False},
        {'nombre': 'Sábado', 'festivo': False},
        {'nombre': 'Domingo', 'festivo': True}
    ]
    
    # Procesar formulario
    if request.method == 'POST':
        form = PeluqueroForm(request.POST, request.FILES, instance=peluquero)
        if form.is_valid():
            # Procesar horario
            horario_json = request.POST.get('horario_json', '{}')
            try:
                horario_data = json.loads(horario_json)
                peluquero.horario = horario_data
                form.save()
                messages.success(request, "Datos del peluquero actualizados correctamente.")
                return redirect('detalle_peluquero', negocio_id=negocio_id, peluquero_id=peluquero_id)
            except json.JSONDecodeError as e:
                messages.error(request, f"Error en el formato del horario: {str(e)}")
    else:
        form = PeluqueroForm(instance=peluquero)
    
    # Preparar datos para la plantilla
    horario_data = peluquero.horario or {}
    for dia in DIAS_SEMANA:
        dia['turnos'] = horario_data.get(dia['nombre'], {}).get('turnos', [])
    
    # Generar próxima semana con intervalos calculados
    co_holidays = holidays.CountryHoliday('CO')
    today = datetime.now().date()
    proximos_7_dias = []
    
    for delta in range(0, 7):
        fecha = today + timedelta(days=delta)
        nombre_dia = fecha.strftime('%A')
        nombre_dia_es = {
            'Monday': 'Lunes', 
            'Tuesday': 'Martes', 
            'Wednesday': 'Miércoles',
            'Thursday': 'Jueves', 
            'Friday': 'Viernes', 
            'Saturday': 'Sábado',
            'Sunday': 'Domingo'
        }.get(nombre_dia, nombre_dia)
        
        es_festivo = fecha in co_holidays or nombre_dia_es == 'Domingo'
        turnos_config = horario_data.get(nombre_dia_es, {}).get('turnos', [])
        turnos_dia = []
        
        for turno in turnos_config:
            try:
                # Parsear horas y duración
                hora_inicio = datetime.strptime(turno['inicio'], '%H:%M').time()
                hora_fin = datetime.strptime(turno['fin'], '%H:%M').time()
                duracion = int(turno.get('duracion', 30))
                
                # Calcular intervalos para este turno
                intervalos = calcular_intervalos(hora_inicio, hora_fin, duracion)
                
                turnos_dia.append({
                    'inicio': hora_inicio,
                    'fin': hora_fin,
                    'duracion': duracion,
                    'disponible': turno.get('disponible', True),
                    'intervalos': intervalos
                })
            except (ValueError, KeyError) as e:
                print(f"Error procesando turno: {e}")
                continue
        
        proximos_7_dias.append({
            'fecha': fecha,
            'nombre_dia': nombre_dia_es,
            'festivo': es_festivo,
            'turnos': turnos_dia
        })
    
    # Manejo de la galería de imágenes
    galeria_imagenes = peluquero.galeria.all()
    mostrar_defaults = not galeria_imagenes.exists()
    


    if mostrar_defaults:
        default_images = [
            {'nombre': 'Corte Clásico', 'imagen': f'{settings.MEDIA_URL}galeria_default/default1.jpg'},
            {'nombre': 'Degradado Moderno', 'imagen': f'{settings.MEDIA_URL}galeria_default/default2.jpeg'},
            {'nombre': 'Barba Estilizada', 'imagen': f'{settings.MEDIA_URL}galeria_default/default3.jpeg'},
            {'nombre': 'Corte Fade', 'imagen': f'{settings.MEDIA_URL}galeria_default/default4.jpeg'},
            {'nombre': 'Tinte Profesional', 'imagen': f'{settings.MEDIA_URL}galeria_default/default5.jpg'},
            {'nombre': 'Corte Pompadour', 'imagen': f'{settings.MEDIA_URL}galeria_default/default6.jpg'},
            {'nombre': 'Arreglo de Barba', 'imagen': f'{settings.MEDIA_URL}galeria_default/default7.jpg'},
            {'nombre': 'Corte Undercut', 'imagen': f'{settings.MEDIA_URL}galeria_default/default8.jpg'},
        ]
        galeria_imagenes = default_images
    
    return render(request, 'negocios/detalle_peluquero.html', {
        'peluquero': peluquero,
        'form': form,
        'form_imagen': ImagenGaleriaForm(),
        'dias_semana': DIAS_SEMANA,
        'proximos_7_dias': proximos_7_dias,
        'horario_json': json.dumps(horario_data),
        'galeria_imagenes': galeria_imagenes,
        'mostrar_defaults': mostrar_defaults
    })

def calcular_intervalos(inicio, fin, duracion_minutos):
    """Calcula los intervalos de tiempo basados en la duración configurada"""
    intervalos = []
    
    # Convertir a minutos desde medianoche para facilitar cálculos
    inicio_minutos = inicio.hour * 60 + inicio.minute
    fin_minutos = fin.hour * 60 + fin.minute
    
    # Validar que la duración sea positiva
    duracion_minutos = max(1, duracion_minutos)
    
    tiempo_actual = inicio_minutos
    
    while tiempo_actual + duracion_minutos <= fin_minutos:
        # Calcular hora inicio y fin para este intervalo
        h_inicio = tiempo_actual // 60
        m_inicio = tiempo_actual % 60
        h_fin = (tiempo_actual + duracion_minutos) // 60
        m_fin = (tiempo_actual + duracion_minutos) % 60
        
        # Crear objetos time para el intervalo
        inicio_intervalo = time(h_inicio, m_inicio)
        fin_intervalo = time(h_fin, m_fin)
        
        intervalos.append({
            'inicio': inicio_intervalo,
            'fin': fin_intervalo
        })
        
        # Avanzar al siguiente intervalo
        tiempo_actual += duracion_minutos
    
    return intervalos


from django.views.decorators.http import require_POST

@login_required
def eliminar_peluquero(request, negocio_id, peluquero_id):
    peluquero = get_object_or_404(Peluquero, id=peluquero_id, negocio_id=negocio_id, negocio__propietario=request.user)

    if request.method == 'POST':
        confirmar = request.POST.get('confirmar')
        if confirmar == 'SI':
            peluquero.activo = False
            peluquero.save()
            messages.success(request, "Peluquero desactivado correctamente.")
            return redirect('panel_negocio', negocio_id=negocio_id)
        else:
            messages.info(request, "Operación cancelada.")
            return redirect('panel_negocio', negocio_id=negocio_id)

    return render(request, 'negocios/confirmar_eliminacion_peluquero.html', {
        'peluquero': peluquero,
        'negocio_id': negocio_id
    })  
    
import holidays

def festivos_colombia():
    co_holidays = holidays.CountryHoliday('CO')
    return [date for date in co_holidays]


@require_POST
@login_required
def asignar_horario_negocio(request, negocio_id):
    negocio = get_object_or_404(Negocio, id=negocio_id, propietario=request.user)

    dias_activos = request.POST.getlist('dias_activos')
    horarios = {}

    for dia in dias_activos:
        inicio = request.POST.get(f'inicio_{dia}')
        fin = request.POST.get(f'fin_{dia}')
        if inicio and fin:
            horarios[dia] = {'inicio': inicio, 'fin': fin}

    # Suponiendo que tienes un campo JSON o TextField en el modelo para almacenar esto:
    negocio.horario_atencion = horarios
    negocio.save()

    messages.success(request, "Horario asignado correctamente.")
    return redirect('panel_negocio', negocio_id=negocio.id)



def perfil_peluquero(request, id):
    peluquero = get_object_or_404(Peluquero, id=id)
    
    if request.method == 'POST' and 'nueva_imagen' in request.POST:
        form_imagen = ImagenGaleriaForm(request.POST, request.FILES)
        if form_imagen.is_valid():
            nueva = form_imagen.save(commit=False)
            nueva.peluquero = peluquero
            nueva.save()
            return redirect(request.path_info)
    else:
        form_imagen = ImagenGaleriaForm()

    return render(request, 'tu_template.html', {
        'peluquero': peluquero,
        'form_imagen': form_imagen,
        # otros contextos
    })


@login_required
def api_turnos_peluquero(request, peluquero_id):
    peluquero = get_object_or_404(Peluquero, id=peluquero_id, negocio__propietario=request.user)
    
    try:
        horario = json.loads(peluquero.horario) if peluquero.horario else {}
    except json.JSONDecodeError:
        horario = {}
    
    # Obtener días festivos
    co_holidays = holidays.CountryHoliday('CO')
    
    # Generar eventos para el calendario
    eventos = []
    base_date = datetime.today().date()
    
    # Para cada día de las próximas 4 semanas
    for delta in range(0, 28):
        fecha = base_date + timedelta(days=delta)
        dia_semana = fecha.strftime('%A')
        
        # Traducir día de la semana al español
        dias_traduccion = {
            'Monday': 'Lunes',
            'Tuesday': 'Martes',
            'Wednesday': 'Miércoles',
            'Thursday': 'Jueves',
            'Friday': 'Viernes',
            'Saturday': 'Sábado',
            'Sunday': 'Domingo'
        }
        nombre_dia = dias_traduccion.get(dia_semana, dia_semana)
        
        # Verificar si es festivo
        es_festivo = fecha in co_holidays or nombre_dia == 'Domingo'
        
        # Si hay horario para este día y no es festivo
        if nombre_dia in horario and not es_festivo:
            for turno in horario[nombre_dia]['turnos']:
                try:
                    hora_inicio = datetime.strptime(turno['inicio'], '%H:%M').time()
                    hora_fin = datetime.strptime(turno['fin'], '%H:%M').time()
                    
                    start = datetime.combine(fecha, hora_inicio).isoformat()
                    end = datetime.combine(fecha, hora_fin).isoformat()
                    
                    eventos.append({
                        "title": "Disponible",
                        "start": start,
                        "end": end,
                        "color": "#28a745",  # verde
                        "extendedProps": {
                            "duracion": turno.get('duracion', 30)
                        }
                    })
                except (ValueError, KeyError):
                    continue
    
    return JsonResponse(eventos, safe=False)


@login_required
def agregar_imagen_galeria(request, negocio_id, peluquero_id):
    peluquero = get_object_or_404(
        Peluquero, 
        id=peluquero_id, 
        negocio_id=negocio_id, 
        negocio__propietario=request.user
    )
    
    if request.method == 'POST':
        print("Datos del formulario recibidos:", request.POST)  # Debug
        print("Archivos recibidos:", request.FILES)  # Debug
        
        form = ImagenGaleriaForm(request.POST, request.FILES)
        if form.is_valid():
            print("Formulario válido")  # Debug
            imagen = form.save(commit=False)
            imagen.peluquero = peluquero
            imagen.save()
            print("Imagen guardada con ID:", imagen.id)  # Debug
            messages.success(request, "Imagen agregada a la galería.")
            return redirect('detalle_peluquero', negocio_id=negocio_id, peluquero_id=peluquero_id)
        else:
            print("Errores del formulario:", form.errors)  # Debug
            messages.error(request, "Error al subir la imagen.")
    
    return redirect('detalle_peluquero', negocio_id=negocio_id, peluquero_id=peluquero_id)

logger = logging.getLogger(__name__)
@require_POST
@login_required

def eliminar_imagen_galeria(request, imagen_id):
    logger.info(f"Intento de eliminar imagen ID: {imagen_id} por usuario: {request.user}")
    try:
        imagen = ImagenGaleria.objects.get(
            id=imagen_id,
            peluquero__negocio__propietario=request.user
        )
        imagen.imagen.delete()  # Elimina el archivo físico
        imagen.delete()         # Elimina el registro de la BD
        return JsonResponse({'success': True})
    except ImagenGaleria.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Imagen no encontrada'}, status=404)
